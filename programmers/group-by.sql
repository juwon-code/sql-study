-- L2. 자동차 종류 별 특정 옵션이 포함된 자동차 수 구하기
SELECT
    CAR_TYPE,
    COUNT(*) AS CARS
FROM CAR_RENTAL_COMPANY_CAR
WHERE OPTIONS REGEXP "통풍시트|가죽시트|열선시트"
GROUP BY CAR_TYPE
ORDER BY CAR_TYPE;


-- L2. 성분으로 구분한 아이스크림 총 주문량
SELECT
    INGREDIENT_TYPE,
    SUM(TOTAL_ORDER) AS TOTAL_ORDER
FROM FIRST_HALF F
INNER JOIN ICECREAM_INFO I
    ON F.FLAVOR = I.FLAVOR
GROUP BY INGREDIENT_TYPE
ORDER BY TOTAL_ORDER ASC;


-- L2. 진료과별 총 예약 횟수 출력하기
SELECT
    MCDP_CD AS 진료과코드,
    COUNT(*) AS 5월예약건수
FROM APPOINTMENT
WHERE APNT_YMD BETWEEN "2022-05-01" AND "2022-05-31"
GROUP BY 진료과코드
ORDER BY 5월예약건수, 진료과코드;


-- L2. 고양이와 개는 몇 마리 있을까
SELECT
    ANIMAL_TYPE,
    COUNT(*) AS COUNT
FROM ANIMAL_INS
WHERE ANIMAL_TYPE IN ('CAT', 'DOG')
GROUP BY ANIMAL_TYPE
ORDER BY ANIMAL_TYPE ASC


-- L2. 동명 동물 수 찾기
SELECT
    NAME,
    COUNT(*) AS COUNT
FROM ANIMAL_INS
GROUP BY NAME
HAVING COUNT(NAME) >= 2
ORDER BY NAME;


-- L2. 입양 시각 구하기(1)
SELECT
    HOUR(DATETIME) AS HOUR,
    COUNT(*) AS COUNT
FROM ANIMAL_OUTS
WHERE HOUR(DATETIME) BETWEEN "9" AND "19"
GROUP BY HOUR
ORDER BY HOUR;


-- L2. 가격대 별 상품 개수 구하기
SELECT
    TRUNCATE(PRICE, -4) AS PRICE_GROUP,
    COUNT(*) AS PRODUCTS
FROM PRODUCT
GROUP BY PRICE_GROUP
ORDER BY PRICE_GROUP


-- L2. 조건에 맞는 사원 정보 조회하기
SELECT
    SUM(SCORE) AS SCORE,
    HE.EMP_NO,
    HE.EMP_NAME,
    HE.POSITION,
    HE.EMAIL
FROM HR_EMPLOYEES HE
LEFT JOIN HR_DEPARTMENT HD
    ON HE.DEPT_ID = HD.DEPT_ID
LEFT JOIN HR_GRADE HG
    ON HE.EMP_NO = HG.EMP_NO
GROUP BY HE.EMP_NO
ORDER BY SCORE DESC
LIMIT 1;


-- L2. 노선별 평균 역 사이 거리 조회하기
SELECT
    ROUTE,
    CONCAT(ROUND(SUM(D_BETWEEN_DIST), 1), "km") AS TOTAL_DISTANCE,
    CONCAT(ROUND(AVG(D_BETWEEN_DIST), 2), "km") AS AVERAGE_DISTANCE
FROM SUBWAY_DISTANCE
GROUP BY ROUTE
ORDER BY ROUTE DESC;


-- L2. 물고기 종류 별 잡은 수 구하기
SELECT
    COUNT(*) AS FISH_COUNT,
    N.FISH_NAME
FROM FISH_NAME_INFO N
INNER JOIN FISH_INFO I
    ON N.FISH_TYPE = I.FISH_TYPE
GROUP BY FISH_NAME
ORDER BY FISH_COUNT DESC;


-- L2. 월별 잡은 물고기 수 구하기
SELECT
    COUNT(*) AS FISH_COUNT,
    MONTH(TIME) AS MONTH
FROM FISH_INFO
GROUP BY MONTH
ORDER BY MONTH;

-- L3. 조건에 맞는 사용자와 총 거래금액 조회하기
WITH CTE_TOTAL AS (
    SELECT
        USER_ID,
        NICKNAME,
        SUM(PRICE) AS TOTAL_SALES
    FROM USED_GOODS_BOARD B
    INNER JOIN USED_GOODS_USER U
        ON B.WRITER_ID = U.USER_ID
    WHERE B.STATUS = "DONE"
    GROUP BY WRITER_ID
)

SELECT *
FROM CTE_TOTAL
WHERE TOTAL_SALES >= 700000
ORDER BY TOTAL_SALES;


-- L3. 카테고리 별 도서 판매량 집계하기
SELECT
    CATEGORY,
    SUM(SALES) AS TOTAL_SALES
FROM BOOK B
INNER JOIN BOOK_SALES S
    ON B.BOOK_ID = S.BOOK_ID
WHERE SALES_DATE BETWEEN "2022-01-01" AND "2022-01-31"
GROUP BY CATEGORY
ORDER BY CATEGORY;


-- L3. 즐겨찾기가 가장 많은 식당 정보 출력하기
WITH CTE_FAVORITES AS (
    SELECT
        FOOD_TYPE,
        MAX(FAVORITES) AS FAVORITES
    FROM REST_INFO
    GROUP BY FOOD_TYPE
)

SELECT
    I.FOOD_TYPE,
    I.REST_ID,
    I.REST_NAME,
    I.FAVORITES
FROM REST_INFO I
INNER JOIN CTE_FAVORITES C
    ON I.FOOD_TYPE = C.FOOD_TYPE
WHERE I.FOOD_TYPE = C.FOOD_TYPE
AND I.FAVORITES = C.FAVORITES
ORDER BY I.FOOD_TYPE DESC;


-- L3. 자동차 대여 기록에서 대여중 / 대여 가능 여부 구분하기
SELECT
    CAR_ID,
    CASE WHEN SUM(
        CASE WHEN "2022-10-16" BETWEEN START_DATE AND END_DATE
        THEN 1 ELSE 0
        END
    ) = 0
    THEN "대여 가능"
    ELSE "대여중"
    END AS AVAILABILITY
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
GROUP BY CAR_ID
ORDER BY CAR_ID DESC;


-- L3. 대여 횟수가 많은 자동차들의 월별 대여 횟수 구하기
SELECT
    MONTH(START_DATE) AS MONTH,
    CAR_ID,
    COUNT(*) AS COUNT
FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
WHERE MONTH(START_DATE) BETWEEN 8 AND 10
AND CAR_ID IN (
    SELECT CAR_ID
    FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY
    WHERE MONTH(START_DATE) BETWEEN 8 AND 10
    GROUP BY CAR_ID
    HAVING COUNT(*) >= 5
)
GROUP BY CAR_ID, MONTH(START_DATE)
ORDER BY MONTH, CAR_ID DESC;


-- L3. 부서별 평균 연봉 조회하기
SELECT
    D.DEPT_ID,
    DEPT_NAME_EN,
    ROUND(AVG(SAL), 0) AS AVG_SAL
FROM HR_DEPARTMENT AS D
INNER JOIN HR_EMPLOYEES AS E
    ON D.DEPT_ID = E.DEPT_ID
GROUP BY DEPT_ID
ORDER BY AVG_SAL DESC;


-- L3. 특정 조건을 만족하는 물고기별 수와 최대 길이 구하기
WITH CTE_AVG AS (
    SELECT
        CASE 
            WHEN LENGTH IS NULL THEN 10
            ELSE LENGTH
        END AS LENGTH,
        FISH_TYPE
    FROM FISH_INFO
)

SELECT
    COUNT(*) AS FISH_COUNT,
    MAX(LENGTH) AS MAX_LENGTH,
    FISH_TYPE
FROM CTE_AVG
GROUP BY FISH_TYPE
HAVING AVG(LENGTH) >= 33
ORDER BY FISH_TYPE;


-- L4. 저자 별 카테고리 별 매출액 집계하기
SELECT
    B.AUTHOR_ID,
    C.AUTHOR_NAME,
    B.CATEGORY,
    SUM(B.PRICE * A.SALES) AS TOTAL_SALES
FROM BOOK_SALES A
INNER JOIN BOOK B
    ON A.BOOK_ID = B.BOOK_ID
INNER JOIN AUTHOR C
    ON B.AUTHOR_ID = C.AUTHOR_ID
WHERE SALES_DATE BETWEEN "2022-01-01" AND "2022-01-31"
GROUP BY AUTHOR_ID, CATEGORY
ORDER BY AUTHOR_ID, CATEGORY DESC;


-- L4. 식품분류별 가장 비싼 식품의 정보 조회하기
WITH CTE_MAX_PRICE AS (
    SELECT
        CATEGORY,
        MAX(PRICE) AS MAX_PRICE
    FROM FOOD_PRODUCT
    WHERE CATEGORY IN("과자", "국", "김치", "식용유")
    GROUP BY CATEGORY
)

SELECT
    MP.CATEGORY,
    MAX_PRICE,
    PRODUCT_NAME
FROM FOOD_PRODUCT P
JOIN CTE_MAX_PRICE MP
    ON P.CATEGORY = MP.CATEGORY
WHERE P.PRICE = MP.MAX_PRICE
ORDER BY PRICE DESC;


-- L4. 년, 월, 성별 별 상품 구매 회원 수 구하기
WITH CTE_USER AS (
    SELECT
        SALES_DATE,
        O.USER_ID,
        PRODUCT_ID,
        GENDER
    FROM ONLINE_SALE O
    INNER JOIN USER_INFO U
        ON O.USER_ID = U.USER_ID
    WHERE GENDER IS NOT NULL
)

SELECT
    YEAR(SALES_DATE) AS YEAR,
    MONTH(SALES_DATE) AS MONTH,
    GENDER,
    COUNT(DISTINCT USER_ID) AS USERS
FROM CTE_USER
GROUP BY YEAR, MONTH, GENDER
ORDER BY YEAR, MONTH, GENDER;


-- L4. 입양 시각 구하기(2)
WITH RECURSIVE CTE_HOUR_COUNT AS (
    SELECT 0 AS HOUR
    UNION ALL
    SELECT HOUR + 1
    FROM CTE_HOUR_COUNT
    WHERE HOUR < 23
)

SELECT
    HC.HOUR,
    COUNT(ANIMAL_ID) AS COUNT
FROM CTE_HOUR_COUNT HC
LEFT JOIN ANIMAL_OUTS AO
    ON HC.HOUR = HOUR(AO.DATETIME)
GROUP BY HC.HOUR
ORDER BY HC.HOUR;


-- L4. 언어별 개발자 분류하기
WITH CTE_DEVELOPERS AS (
    SELECT
        D.ID,
        D.EMAIL,
        GROUP_CONCAT(DISTINCT S.NAME, S.CATEGORY ORDER BY S.NAME SEPARATOR ', ') AS SKILLS_CATEGORY
    FROM SKILLCODES S
    JOIN DEVELOPERS D
        ON D.SKILL_CODE & S.CODE
    GROUP BY D.ID, D.EMAIL
)

SELECT
    CASE
        WHEN SKILLS_CATEGORY LIKE '%Front%' AND SKILLS_CATEGORY LIKE '%Python%'
            THEN 'A'
        WHEN SKILLS_CATEGORY LIKE '%C#%'
            THEN 'B'
        WHEN SKILLS_CATEGORY LIKE '%Front%'
            THEN 'C'
    END AS GRADE,
    ID,
    EMAIL
FROM CTE_DEVELOPERS
HAVING GRADE IS NOT NULL
ORDER BY GRADE, ID;


-- L4. 연간 평가점수에 해당하는 평가 등급 및 성과금 조회하기
WITH CTE_GRADE AS (
    SELECT
        DISTINCT EMP_NO,
        CASE
            WHEN AVG(SCORE) OVER(PARTITION BY EMP_NO) >= 96
                THEN "S"
            WHEN AVG(SCORE) OVER(PARTITION BY EMP_NO) >= 90
                THEN "A"
            WHEN AVG(SCORE) OVER(PARTITION BY EMP_NO) >= 80
                THEN "B"
            ELSE "C"
        END AS GRADE
    FROM HR_GRADE
)

SELECT
    CG.EMP_NO,
    EMP_NAME,
    GRADE,
    CASE GRADE
        WHEN "S"
            THEN SAL * 0.2
        WHEN "A"
            THEN SAL * 0.15
        WHEN "B"
            THEN SAL * 0.1
        WHEN "C"
            THEN 0
    END AS BONUS
FROM CTE_GRADE CG
INNER JOIN HR_EMPLOYEES HE
    ON CG.EMP_NO = HE.EMP_NO
ORDER BY CG.EMP_NO;